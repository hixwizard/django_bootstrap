============================= test session starts =============================
platform win32 -- Python 3.9.10, pytest-7.1.3, pluggy-1.0.0 -- D:\Dev\django_sprint4\venv\Scripts\python.exe
django: settings: blogicum.settings (from ini)
rootdir: D:\Dev\django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category FAILED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile PASSED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers PASSED                 [ 32%]
tests/test_users.py::test_custom_err_handlers PASSED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 44%]
tests/test_comment.py::test_comment FAILED                               [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post PASSED           [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post FAILED                                     [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests\conftest.py PASSED [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests\conftest.py PASSED [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests\conftest.py PASSED [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests\conftest.py PASSED [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view PASSED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests\conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests\conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv PASSED              [100%]

================================== FAILURES ===================================
________________________ TestContent.test_unpublished _________________________

self = <test_content.MainPostContentTester object at 0x0000016C8069C8E0>
client = <django.test.client.Client object at 0x0000016C8039A220>, url = '/'
assert_status_in = (200,), assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C8039A220>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C8039A220>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C8039A220>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C8039A220>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=17x39xwp5jkw30f8ium4bq75ii0gh2ln', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C80803A90>, <django.template.base.Template object at 0x0000016C80825AC0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...ents')", "    ).order_by('-pub_date').select_related('category', 'author', 'location')"], 'pre_context_lineno': 9}}]]})
signal_uid = 'template-render-1565523998656'
exception_uid = 'request-exception-1565523998656'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C8039A220>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C8039A310>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request) -> HttpResponse:
        """Отображение главной страницы."""
        template = 'blog/index.html'
>       post_list = short_filter_posts(Post.objects.all())

blogicum\blog\views.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Remain Able Res>, <Post: Share Catch Som>, <Post: Nothing Appear >]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802FCA90>
unpublished_posts_with_published_locations = [<Post: Remain Able Res>, <Post: Share Catch Som>, <Post: Nothing Appear >]

    def test_unpublished(self, unpublished_posts_with_published_locations):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
            self.profile_tester.items_key
        )
        expected_n = self.profile_tester.n_or_page_size(
            len(unpublished_posts_with_published_locations)
        )
        assert len(context_posts) == expected_n, (
            "Убедитесь, что на странице пользователя автор может видеть свои"
            " посты, снятые с публикации."
        )
    
>       response = self.main_tester.user_client_testget()

tests\test_content.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:71: in user_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.MainPostContentTester object at 0x0000016C8069C8E0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что главная страница загружается без ошибок."
        )
E       AssertionError: Убедитесь, что главная страница загружается без ошибок.

tests\test_content.py:228: AssertionError
_________________ TestContent.test_only_own_pubs_in_category __________________

self = <test_content.CategoryPostContentTester object at 0x0000016C8080C310>
client = <django.test.client.Client object at 0x0000016C80A6D490>
url = '/category/song-early-future/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80A6D490>
path = '/category/song-early-future/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80A6D490>
path = '/category/song-early-future/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80A6D490>, method = 'GET'
path = '/category/song-early-future/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/song-early-future/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/song-early-future/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80A6D490>
request = {'PATH_INFO': '/category/song-early-future/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=9ww812vzq4avx8skmbw9wnaft19brlka', 'PATH_INFO': '/category/song-early-future/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C80A5B190>, <django.template.base.Template object at 0x0000016C80A5BBB0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...in one of its', '            # children)', '            if model is not opts.model:'], 'pre_context_lineno': 1555}}]]})
signal_uid = 'template-render-1565526576320'
exception_uid = 'request-exception-1565526576320'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80A6D490>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/song-early-future/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C80A6D460>
request = <WSGIRequest: GET '/category/song-early-future/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/song-early-future/'>
slug = 'song-early-future'

    def category_detail(request, slug) -> HttpResponse:
        """Отображение страницы с информацией о категории."""
        template = 'blog/category.html'
    
        category = get_object_or_404(Category, slug=slug, is_published=True)
        post_list = full_filter_posts(
>           Post.objects.filter(category_slug=slug)
        )

blogicum\blog\views.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.Manager object at 0x0000016C80731F70>
args = (), kwargs = {'category_slug': 'song-early-future'}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv\lib\site-packages\django\db\models\manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <QuerySet [<Post: Among Culture F>, <Post: Interview Himse>]>, args = ()
kwargs = {'category_slug': 'song-early-future'}

    def filter(self, *args, **kwargs):
        """
        Return a new QuerySet instance with the args ANDed to the existing
        set.
        """
        self._not_support_combined_queries('filter')
>       return self._filter_or_exclude(False, args, kwargs)

venv\lib\site-packages\django\db\models\query.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <QuerySet [<Post: Among Culture F>, <Post: Interview Himse>]>
negate = False, args = (), kwargs = {'category_slug': 'song-early-future'}

    def _filter_or_exclude(self, negate, args, kwargs):
        if args or kwargs:
            assert not self.query.is_sliced, \
                "Cannot filter a query once a slice has been taken."
    
        clone = self._chain()
        if self._defer_next_filter:
            self._defer_next_filter = False
            clone._deferred_filter = negate, args, kwargs
        else:
>           clone._filter_or_exclude_inplace(negate, args, kwargs)

venv\lib\site-packages\django\db\models\query.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <QuerySet [<Post: Among Culture F>, <Post: Interview Himse>]>
negate = False, args = (), kwargs = {'category_slug': 'song-early-future'}

    def _filter_or_exclude_inplace(self, negate, args, kwargs):
        if negate:
            self._query.add_q(~Q(*args, **kwargs))
        else:
>           self._query.add_q(Q(*args, **kwargs))

venv\lib\site-packages\django\db\models\query.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.sql.query.Query object at 0x0000016C809D2A60>
q_object = <Q: (AND: ('category_slug', 'song-early-future'))>

    def add_q(self, q_object):
        """
        A preprocessor for the internal _add_q(). Responsible for doing final
        join promotion.
        """
        # For join promotion this case is doing an AND for the added q_object
        # and existing conditions. So, any existing inner join forces the join
        # type to remain inner. Existing outer joins can however be demoted.
        # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if
        # rel_a doesn't produce any rows, then the whole condition must fail.
        # So, demotion is OK.
        existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
>       clause, _ = self._add_q(q_object, self.used_aliases)

venv\lib\site-packages\django\db\models\sql\query.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.sql.query.Query object at 0x0000016C809D2A60>
q_object = <Q: (AND: ('category_slug', 'song-early-future'))>
used_aliases = set(), branch_negated = False, current_negated = False
allow_joins = True, split_subq = True, check_filterable = True

    def _add_q(self, q_object, used_aliases, branch_negated=False,
               current_negated=False, allow_joins=True, split_subq=True,
               check_filterable=True):
        """Add a Q-object to the current filter."""
        connector = q_object.connector
        current_negated = current_negated ^ q_object.negated
        branch_negated = branch_negated or q_object.negated
        target_clause = self.where_class(connector=connector,
                                         negated=q_object.negated)
        joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
        for child in q_object.children:
>           child_clause, needed_inner = self.build_filter(
                child, can_reuse=used_aliases, branch_negated=branch_negated,
                current_negated=current_negated, allow_joins=allow_joins,
                split_subq=split_subq, check_filterable=check_filterable,
            )

venv\lib\site-packages\django\db\models\sql\query.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.sql.query.Query object at 0x0000016C809D2A60>
filter_expr = ('category_slug', 'song-early-future'), branch_negated = False
current_negated = False, can_reuse = set(), allow_joins = True
split_subq = True, reuse_with_filtered_relation = False, check_filterable = True

    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                     can_reuse=None, allow_joins=True, split_subq=True,
                     reuse_with_filtered_relation=False, check_filterable=True):
        """
        Build a WhereNode for a single filter clause but don't add it
        to this Query. Query.add_q() will then add this filter to the where
        Node.
    
        The 'branch_negated' tells us if the current branch contains any
        negations. This will be used to determine if subqueries are needed.
    
        The 'current_negated' is used to determine if the current filter is
        negated or not and this will be used to determine if IS NULL filtering
        is needed.
    
        The difference between current_negated and branch_negated is that
        branch_negated is set on first negation, but current_negated is
        flipped for each negation.
    
        Note that add_filter will not do any negating itself, that is done
        upper in the code by add_q().
    
        The 'can_reuse' is a set of reusable joins for multijoins.
    
        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
        will be reused.
    
        The method will create a filter clause that can be added to the current
        query. However, if the filter isn't added to the query then the caller
        is responsible for unreffing the joins used.
        """
        if isinstance(filter_expr, dict):
            raise FieldError("Cannot parse keyword query as dict")
        if isinstance(filter_expr, Q):
            return self._add_q(
                filter_expr,
                branch_negated=branch_negated,
                current_negated=current_negated,
                used_aliases=can_reuse,
                allow_joins=allow_joins,
                split_subq=split_subq,
                check_filterable=check_filterable,
            )
        if hasattr(filter_expr, 'resolve_expression'):
            if not getattr(filter_expr, 'conditional', False):
                raise TypeError('Cannot filter against a non-conditional expression.')
            condition = self.build_lookup(
                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True
            )
            clause = self.where_class()
            clause.add(condition, AND)
            return clause, []
        arg, value = filter_expr
        if not arg:
            raise FieldError("Cannot parse keyword query %r" % arg)
>       lookups, parts, reffed_expression = self.solve_lookup_type(arg)

venv\lib\site-packages\django\db\models\sql\query.py:1309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.sql.query.Query object at 0x0000016C809D2A60>
lookup = 'category_slug'

    def solve_lookup_type(self, lookup):
        """
        Solve the lookup type from the lookup (e.g.: 'foobar__id__icontains').
        """
        lookup_splitted = lookup.split(LOOKUP_SEP)
        if self.annotations:
            expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)
            if expression:
                return expression_lookups, (), expression
>       _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())

venv\lib\site-packages\django\db\models\sql\query.py:1135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.sql.query.Query object at 0x0000016C809D2A60>
names = ['category_slug'], opts = <Options for Post>, allow_many = True
fail_on_missing = False

    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):
        """
        Walk the list of names and turns them into PathInfo tuples. A single
        name in 'names' can generate multiple PathInfos (m2m, for example).
    
        'names' is the path of names to travel, 'opts' is the model Options we
        start the name resolving from, 'allow_many' is as for setup_joins().
        If fail_on_missing is set to True, then a name that can't be resolved
        will generate a FieldError.
    
        Return a list of PathInfo tuples. In addition return the final field
        (the last used join field) and target (which is a field guaranteed to
        contain the same value as the final field). Finally, return those names
        that weren't found (which are likely transforms and the final lookup).
        """
        path, names_with_path = [], []
        for pos, name in enumerate(names):
            cur_names_with_path = (name, [])
            if name == 'pk':
                name = opts.pk.name
    
            field = None
            filtered_relation = None
            try:
                field = opts.get_field(name)
            except FieldDoesNotExist:
                if name in self.annotation_select:
                    field = self.annotation_select[name].output_field
                elif name in self._filtered_relations and pos == 0:
                    filtered_relation = self._filtered_relations[name]
                    if LOOKUP_SEP in filtered_relation.relation_name:
                        parts = filtered_relation.relation_name.split(LOOKUP_SEP)
                        filtered_relation_path, field, _, _ = self.names_to_path(
                            parts, opts, allow_many, fail_on_missing,
                        )
                        path.extend(filtered_relation_path[:-1])
                    else:
                        field = opts.get_field(filtered_relation.relation_name)
            if field is not None:
                # Fields that contain one-to-many relations with a generic
                # model (like a GenericForeignKey) cannot generate reverse
                # relations and therefore cannot be used for reverse querying.
                if field.is_relation and not field.related_model:
                    raise FieldError(
                        "Field %r does not generate an automatic reverse "
                        "relation and therefore cannot be used for reverse "
                        "querying. If it is a GenericForeignKey, consider "
                        "adding a GenericRelation." % name
                    )
                try:
                    model = field.model._meta.concrete_model
                except AttributeError:
                    # QuerySet.annotate() may introduce fields that aren't
                    # attached to a model.
                    model = None
            else:
                # We didn't find the current field, so move position back
                # one step.
                pos -= 1
                if pos == -1 or fail_on_missing:
                    available = sorted([
                        *get_field_names_from_opts(opts),
                        *self.annotation_select,
                        *self._filtered_relations,
                    ])
>                   raise FieldError("Cannot resolve keyword '%s' into field. "
                                     "Choices are: %s" % (name, ", ".join(available)))
E                   django.core.exceptions.FieldError: Cannot resolve keyword 'category_slug' into field. Choices are: author, author_id, category, category_id, comments, created_at, id, image, is_published, location, location_id, pub_date, text, title

venv\lib\site-packages\django\db\models\sql\query.py:1562: FieldError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802F5100>
user_client = <django.test.client.Client object at 0x0000016C80A6D490>
post_with_published_location = <Post: Among Culture F>
post_with_another_category = <Post: Interview Himse>

    def test_only_own_pubs_in_category(
        self, user_client, post_with_published_location,
            post_with_another_category
    ):
>       response = self.category_tester.user_client_testget()

tests\test_content.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:71: in user_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.CategoryPostContentTester object at 0x0000016C8080C310>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница категории загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница категории загружается без ошибок.

tests\test_content.py:266: AssertionError
____________________ TestContent.test_unpublished_category ____________________

self = <test_content.MainPostContentTester object at 0x0000016C8044CB80>
client = <django.test.client.Client object at 0x0000016C80476460>, url = '/'
assert_status_in = (200,), assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80476460>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80476460>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80476460>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80476460>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=oomn86utv0iuynntbuqhojdyk1jtp7mw', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C8078CD00>, <django.template.base.Template object at 0x0000016C8080CEE0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...ents')", "    ).order_by('-pub_date').select_related('category', 'author', 'location')"], 'pre_context_lineno': 9}}]]})
signal_uid = 'template-render-1565521009856'
exception_uid = 'request-exception-1565521009856'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C80476460>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C80512A60>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request) -> HttpResponse:
        """Отображение главной страницы."""
        template = 'blog/index.html'
>       post_list = short_filter_posts(Post.objects.all())

blogicum\blog\views.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: End Boy Propert>, <Post: Industry Nor Pa>, <Post: Production To T>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802F5DF0>
user_client = <django.test.client.Client object at 0x0000016C80476460>
posts_with_unpublished_category = [<Post: End Boy Propert>, <Post: Industry Nor Pa>, <Post: Production To T>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
            self.profile_tester.items_key
        )
        expected_n = self.profile_tester.n_or_page_size(
            len(posts_with_unpublished_category)
        )
        assert len(context_posts) == expected_n, (
            "Убедитесь, что на странице пользователя автор может видеть свои"
            " посты, принадлежащие категории, снятой с публикации."
        )
    
>       main_response = self.main_tester.user_client_testget()

tests\test_content.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:71: in user_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.MainPostContentTester object at 0x0000016C8044CB80>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что главная страница загружается без ошибок."
        )
E       AssertionError: Убедитесь, что главная страница загружается без ошибок.

tests\test_content.py:228: AssertionError
________________________ TestContent.test_future_posts ________________________

self = <test_content.MainPostContentTester object at 0x0000016C81CADDF0>
client = <django.test.client.Client object at 0x0000016C81CADE20>, url = '/'
assert_status_in = (200,), assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81CADE20>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81CADE20>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81CADE20>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81CADE20>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=2gjiothfz7dw5d40vm0v9vy76lb5nrzm', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C805293D0>, <django.template.base.Template object at 0x0000016C80591C40>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...ents')", "    ).order_by('-pub_date').select_related('category', 'author', 'location')"], 'pre_context_lineno': 9}}]]})
signal_uid = 'template-render-1565545761600'
exception_uid = 'request-exception-1565545761600'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81CADE20>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C81CADB80>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request) -> HttpResponse:
        """Отображение главной страницы."""
        template = 'blog/index.html'
>       post_list = short_filter_posts(Post.objects.all())

blogicum\blog\views.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Born Human Spac>, <Post: Outside Suddenl>, <Post: Step Officer Ap>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802F11C0>
user_client = <django.test.client.Client object at 0x0000016C81CADE20>
future_posts = [<Post: Born Human Spac>, <Post: Outside Suddenl>, <Post: Step Officer Ap>]

    def test_future_posts(self, user_client, future_posts):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
            self.profile_tester.items_key
        )
        expected_n = self.profile_tester.n_or_page_size(len(future_posts))
        assert len(context_posts) == expected_n, (
            "Убедитесь, что на странице пользователя автор может видеть свои"
            " отложенные публикации."
        )
    
>       response = self.main_tester.user_client_testget()

tests\test_content.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:71: in user_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.MainPostContentTester object at 0x0000016C81CADDF0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что главная страница загружается без ошибок."
        )
E       AssertionError: Убедитесь, что главная страница загружается без ошибок.

tests\test_content.py:228: AssertionError
_________________________ TestContent.test_pagination _________________________

self = <test_content.ProfilePostContentTester object at 0x0000016C81AF7490>
client = <django.test.client.Client object at 0x0000016C81AF75B0>
url = '/profile/dawn15/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81AF75B0>
path = '/profile/dawn15/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81AF75B0>
path = '/profile/dawn15/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81AF75B0>, method = 'GET'
path = '/profile/dawn15/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/dawn15/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/dawn15/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81AF75B0>
request = {'PATH_INFO': '/profile/dawn15/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=oasld5uusl1hio7idf2m3nuhwicqp7ra', 'PATH_INFO': '/profile/dawn15/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C8060F610>, <django.template.base.Template object at 0x0000016C8058AF70>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...ents')", "    ).order_by('-pub_date').select_related('category', 'author', 'location')"], 'pre_context_lineno': 9}}]]})
signal_uid = 'template-render-1565521308352'
exception_uid = 'request-exception-1565521308352'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C81AF75B0>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/profile/dawn15/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C81AF7520>
request = <WSGIRequest: GET '/profile/dawn15/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/profile/dawn15/'>, args = ()
kwargs = {'username': 'dawn15'}
self = <blog.views.ProfileView object at 0x0000016C8045A220>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

venv\lib\site-packages\django\views\generic\base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blog.views.ProfileView object at 0x0000016C8045A220>
request = <WSGIRequest: GET '/profile/dawn15/'>, args = ()
kwargs = {'username': 'dawn15'}
handler = <bound method BaseListView.get of <blog.views.ProfileView object at 0x0000016C8045A220>>

    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
>       return handler(request, *args, **kwargs)

venv\lib\site-packages\django\views\generic\base.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blog.views.ProfileView object at 0x0000016C8045A220>
request = <WSGIRequest: GET '/profile/dawn15/'>, args = ()
kwargs = {'username': 'dawn15'}

    def get(self, request, *args, **kwargs):
>       self.object_list = self.get_queryset()

venv\lib\site-packages\django\views\generic\list.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blog.views.ProfileView object at 0x0000016C8045A220>

    def get_queryset(self):
        author = self.get_author()
        posts = author.posts.all().order_by('-pub_date')
        if author != self.request.user:
>           posts = short_filter_posts(posts)

blogicum\blog\views.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Seem Treatment >, <Post: Alone Others An>, <Post: Series Image Ef>, <Post: Cut Tonight Key>, <Post: ... Dark Firm Value>, <Post: Church Citizen >, <Post: Government Big >, <Post: Move Fast Envir>, <Post: Save Theory Wee>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802F1790>
user_client = <django.test.client.Client object at 0x0000016C81AF7B50>
many_posts_with_published_locations = [<Post: Dark Firm Value>, <Post: Family Seek Lea>, <Post: Church Citizen >, <Post: Rate Day Serve >, <Post: Reality Goal Re>, <Post: Boy Case Sport >, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests\test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:83: in another_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.ProfilePostContentTester object at 0x0000016C81AF7490>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests\test_content.py:202: AssertionError
_______________________ TestContent.test_image_visible ________________________

self = <test_content.MainPostContentTester object at 0x0000016C805FA070>
client = <django.test.client.Client object at 0x0000016C805FA760>, url = '/'
assert_status_in = (200,), assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests\test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C805FA760>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C805FA760>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C805FA760>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C805FA760>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=bns48w3rpc3kqtyemoa5spjw64rl9aky', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000016C80442A30>, <django.template.base.Template object at 0x0000016C81AF6880>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000016CFFB438B0>, {'templates': [<django.template.base.Temp...ents')", "    ).order_by('-pub_date').select_related('category', 'author', 'location')"], 'pre_context_lineno': 9}}]]})
signal_uid = 'template-render-1565521999360'
exception_uid = 'request-exception-1565521999360'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000016C805FA760>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000016C805FA850>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request) -> HttpResponse:
        """Отображение главной страницы."""
        template = 'blog/index.html'
>       post_list = short_filter_posts(Post.objects.all())

blogicum\blog\views.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Religious Toget>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x0000016C802F1DC0>
user_client = <django.test.client.Client object at 0x0000016C805FA760>
post_with_published_location = <Post: Religious Toget>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests\test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:71: in user_client_testget
    return self._testget(
tests\test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <test_content.MainPostContentTester object at 0x0000016C805FA070>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что главная страница загружается без ошибок."
        )
E       AssertionError: Убедитесь, что главная страница загружается без ошибок.

tests\test_content.py:228: AssertionError
________________________________ test_profile _________________________________

user = <User: umendoza>, another_user = <User: jeancopeland>
user_client = <django.test.client.Client object at 0x0000016C807B8460>
another_user_client = <django.test.client.Client object at 0x0000016C805192B0>
unlogged_client = <django.test.client.Client object at 0x0000016C805D7760>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
            response = user_client.get("/profile/this_is_unexisting_user_name/")
        except User.DoesNotExist:
            raise AssertionError(status_code_not_404_err_msg)
    
        assert response.status_code == HTTPStatus.NOT_FOUND, (
            status_code_not_404_err_msg)
    
        user_response: HttpResponse = user_client.get(user_url)
    
        user_content = user_response.content.decode("utf-8")
    
>       anothers_same_page_response: HttpResponse = another_user_client.get(
            user_url
        )

tests\test_users.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\generic\base.py:70: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\django\views\generic\base.py:98: in dispatch
    return handler(request, *args, **kwargs)
venv\lib\site-packages\django\views\generic\list.py:142: in get
    self.object_list = self.get_queryset()
blogicum\blog\views.py:39: in get_queryset
    posts = short_filter_posts(posts)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet []>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError
________________________________ test_comment _________________________________

user_client = <django.test.client.Client object at 0x0000016C80462850>
another_user_client = <django.test.client.Client object at 0x0000016C81AF6CD0>
unlogged_client = <django.test.client.Client object at 0x0000016C81C5D820>
post_with_published_location = <Post: Scene History T>
another_user = <User: dillon02>
post_comment_context_form_item = KeyVal(key='form', val=<CommentForm bound=False, valid=False, fields=(text)>)
CommentModel = <class 'blog.models.Comment'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
profile_content_tester = <test_content.ProfilePostContentTester object at 0x0000016C807B8040>

    @pytest.mark.django_db(transaction=True)
    def test_comment(
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            post_with_published_location: Any,
            another_user: Model,
            post_comment_context_form_item: Tuple[str, BaseForm],
            CommentModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            profile_content_tester: ProfilePostContentTester
    ):
        post_with_published_location.author = another_user
        post_with_published_location.save()
        _, ctx_form = post_comment_context_form_item
        a_post_get_response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )
    
        # create comments
        creation_tester = CreateCommentFormTester(
            a_post_get_response,
            CommentModel,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=None,
            ModelAdapter=CommentModelAdapter,
        )
    
        Form: Type[BaseForm] = type(ctx_form)
        forms_to_create = create_comment_creation_forms(
            creation_tester, Form, CommentModel, CommentModelAdapter)
    
        response_on_created, created_items = creation_tester.test_create_several(
            forms_to_create[1:], qs=CommentModel.objects.all()
        )
        content = response_on_created.content.decode(encoding="utf8")
        creation_tester.test_creation_response(content, created_items)
    
        comment_count_repr = f"({len(created_items)})"
    
>       index_content = user_client.get("/").content.decode("utf-8")

tests\test_comment.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
blogicum\blog\views.py:51: in index
    post_list = short_filter_posts(Post.objects.all())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Scene History T>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError
__________________________________ test_post __________________________________

published_category = <Category: Almost Place Watch Miss Style Lawyer>
published_location = <Location: Mr. Marc Howell>
user_client = <django.test.client.Client object at 0x0000016C81B80460>
another_user_client = <django.test.client.Client object at 0x0000016C81B80F10>
unlogged_client = <django.test.client.Client object at 0x0000016C81B80E80>
comment_to_a_post = <Comment: Comment object (6)>
create_post_context_form_item = KeyVal(key='form', val=<PostForm bound=False, valid=False, fields=(is_published;title;text;pub_date;location;category;image)>)
PostModel = <class 'blog.models.Post'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
main_content_tester = <test_content.MainPostContentTester object at 0x0000016C81B50640>

    @pytest.mark.django_db(transaction=True)
    def test_post(
            published_category: Model,
            published_location: Model,
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            comment_to_a_post: Model,
            create_post_context_form_item: Tuple[str, BaseForm],
            PostModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            main_content_tester: MainPostContentTester
    ):
        _, ctx_form = create_post_context_form_item
    
        create_a_post_get_response = get_create_a_post_get_response_safely(
            user_client
        )
    
        response_on_created, created_items = _test_create_items(
            PostModel,
            PostModelAdapter,
            another_user_client,
            create_a_post_get_response,
            ctx_form,
            published_category,
            published_location,
            unlogged_client,
            user_client,
        )
    
        # checking images are visible on post creation
        created_content = response_on_created.content.decode('utf-8')
        img_count = created_content.count('<img')
        expected_img_count = main_content_tester.n_or_page_size(len(created_items))
        assert img_count >= expected_img_count, (
            'Убедитесь, что при создании публикации она отображается с картинкой.'
        )
    
        edit_response, edit_url, del_url = _test_edit_post(
            CommentModelAdapter,
            another_user_client,
            comment_to_a_post,
            unlogged_client=unlogged_client,
            user_client=user_client,
        )
    
        item_to_delete_adapter = PostModelAdapter(
            CommentModelAdapter(comment_to_a_post).post
        )
        del_url_addr = del_url.key
    
        del_unexisting_status_404_err_msg = (
            "Убедитесь, что при обращении к странице удаления "
            " несуществующего поста возвращается статус 404."
        )
        delete_tester = DeletePostTester(
            item_to_delete_adapter.item_cls,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=item_to_delete_adapter,
        )
>       delete_tester.test_delete_item(
            qs=item_to_delete_adapter.item_cls.objects.all(),
            delete_url_addr=del_url_addr,
        )

tests\test_post.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\form\delete_tester.py:85: in test_delete_item
    can_delete, response = self.user_can_delete(
tests\form\delete_tester.py:114: in user_can_delete
    response = submitter.test_submit(url=delete_url, data={})
tests\form\base_form_tester.py:448: in test_submit
    response = self.client.post(url, data=data, follow=True)
venv\lib\site-packages\django\test\client.py:753: in post
    response = self._handle_redirects(response, data=data, content_type=content_type, **extra)
venv\lib\site-packages\django\test\client.py:850: in _handle_redirects
    response = request_method(path, data=data, content_type=content_type, follow=False, **extra)
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
blogicum\blog\views.py:51: in index
    post_list = short_filter_posts(Post.objects.all())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

queryset = <QuerySet [<Post: Test create pos>, <Post: Test create pos>, <Post: Test create pos>, <Post: Test create pos>]>

    def short_filter_posts(queryset):
        """Фильтр аннотации и селектов."""
>       return queryset.posts.annotate(
            comment_count=Count('comments')
        ).order_by('-pub_date').select_related('category', 'author', 'location')
E       AttributeError: 'QuerySet' object has no attribute 'posts'

blogicum\blog\querysets.py:16: AttributeError
======================== 9 failed, 16 passed in 3.19s =========================
